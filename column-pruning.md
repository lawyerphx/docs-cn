---
title: 列裁剪
category: performance
---

# 列裁剪

本文将介绍 SQL 逻辑优化中的列裁剪。列裁剪的基本思想是：对于算子中实际不会用到的列，优化器在优化的过程中没有必要保留这些列。删除这些列可以减少 I/O 资源占用，并为后续的优化带来便利。下面是一个列重复的例子：

假设表 t 含有 a、b、c、d 四列，执行如下语句：

```sql
select a from t where b > 5
```

在该查询的过程中，表 t 实际上只有 a,、b 两列会被用到，不会用到 c、d 列的数据。对应到该语句的查询计划，Selection 算子会用到 b 列，之后 DataSource 算子会用到 a、b 两列。而 c、d 两列则都可以裁剪掉，DataSource 算子在读数据时不需要将它们读进来。

出于上述考量，TiDB 会在逻辑优化阶段进行自上而下的扫描，裁剪不需要的列，减少资源浪费。该扫描过程称作 “列裁剪”，对应逻辑优化规则中的 `columnPruner`。

## 算法实现

对于逻辑计划中的一个算子，其所需要的列分为两种：上层算子计算时所需要的列，本层算子计算时所需要的列。从这个原则出发，优化器可以自上向下地计算每个算子所需要的列，在遍历的过程中，维护逻辑计划树中的祖先节点给当前算子带来的“列需求”。

相关代码实现于 `planner/core/` 目录下的 `plan.go` 与 `rule_column_pruning.go` 中，实现接口如下。

```goland
PruneColumns([]*expression.Column) error
```

函数输入即为施加给当前算子的“列需求”集合。 在普通优化器中，列裁剪会发生在逻辑优化的开始和结尾，[相关代码](https://github.com/pingcap/tidb/blob/902231076d56fee9074e4c7bcd03a0d0f0d88524/planner/core/optimizer.go#L61)。 在 cascades 优化器中，列裁剪会发生在 Preprocessing 阶段，[相关代码](https://github.com/pingcap/tidb/blob/ded862fbebc555de98e230ef57310f9162725a9e/planner/cascades/optimize.go#L118)。

## 常见算子的裁剪方法

本章节将介绍几种常见的算子的裁剪方法。默认情况下，优化器不对当前算子进行列裁剪。

### Projection

如果投影的结果中含有上层算子所不需要的列，那么这些列就应该删除掉。基于这个原则，优化器会去除当前算子中不在 列需求集合 中的列。（特别的，对于被赋值或sleep的表达式所涵盖的列，优化器不予删除）

同时投影的列需求和上层算子无关，优化器采用当前投影算子所需要的列作为传递下去的列需求集合。

### Selection

select 算子的条件语句会引入一些新的列，这些列会被优化器加入下传的列需求集合中。

### Aggregation

aggregation 算子的列裁剪相对较为复杂，大致可以分为以下四个阶段：
首先，优化器对于当前算子中的聚合函数进行扫描，如果一个聚合函数的结果没有被上层算子使用，那么就删除这个聚合函数。

接着，优化器遍历所有的列，将各聚合函数所涉及到的列加入下传的列需求集合。

此时，如果所有的聚合函数都在第一阶段被删除掉，优化器会加入一个类型为 FirstRowColumn 的默认聚合函数，来保证逻辑计划的正确性。

最后，优化器遍历当前算子的 group by 条件，对 group by 条件进行裁剪，去除常量和 Null，并将必要列加入下传的列需求集合中。

### Sort 和 TopN

对于排序和 topN 算子，和 aggregation 算子裁剪的第四阶段类似，优化器会对于当前算子的 by 条件进行裁剪，去除常量和 Null，并将必要列加入下传的列需求集合中。

### Join

相对其他算子，Join 算子的列裁剪比较特殊，因为 Join 算子的列是由 Join 的两个对象决定的。同时，由于其独特的性质， Join 算子本身的列裁剪不会对下层算子的列需求产生影响。因此，在优化器中，对于 Join 算子本身列的裁剪发生在下层算子的裁剪之后。具体步骤分为三步：

第一步：优化器从 Join 的条件语句中提取出左右算子的列需求集合，并用其对于左右算子分别进行列裁剪。

第二步：优化器将左右算子裁剪后得到的列进行合并。

第三步：优化器对于合并得到的列进行裁剪。
