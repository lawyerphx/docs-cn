---
title: 列裁剪
category: performance
---

# 列裁剪

列裁剪的基本思想在于：对于算子中实际用不上的列，优化器在优化的过程中没有必要保留它们。 对这些列的删除会减少 I/O 资源占用，并为后续的优化带来便利。下面给出一个列重复的例子：

假设表 t 里面有 a b c d 四列，执行如下语句：

```sql
select a from t where b > 5
```

在该查询的过程中，t 表实际上只有 a, b 两列会被用到，而 c, d 的数据则显得多余。对应到该语句的查询计划，Selection 算子会用到 b 列，下面接着的 DataSource 算子会用到 a, b 两列，而剩下 c, d 两列则都可以裁剪掉，DataSource 算子在读数据时不需要将它们读进来。

出于上述考量，TiDB 会在逻辑优化阶段进行自上而下的扫描，裁剪不需要的列，减少资源浪费。该扫描过程称作 “列裁剪”，对应逻辑优化规则中的 `columnPruner`。

## 算法实现

对于逻辑计划中的一个算子而言，它所需要的列分为两种：上层算子计算时所需要的列，本层算子计算时所需要的列。从这个原则出发，优化器可以自顶向下地计算每个算子所需要的列，在遍历的过程中，维护逻辑计划树中的祖先节点给当前算子带来的“列需求”。

相关代码实现于 `planner/core/` 目录下的 `plan.go` 与 `rule_column_pruning.go` 中，实现接口如下。

```goland
PruneColumns([]*expression.Column) error
```

函数输入即为施加给当前算子的“列需求”集合。 在普通优化器中，列裁剪会发生在逻辑优化的开始和结尾，[相关代码](https://github.com/pingcap/tidb/blob/902231076d56fee9074e4c7bcd03a0d0f0d88524/planner/core/optimizer.go#L61)。 在 cascades 优化器中，列裁剪会发生在 Preprocessing 阶段，[相关代码](https://github.com/pingcap/tidb/blob/ded862fbebc555de98e230ef57310f9162725a9e/planner/cascades/optimize.go#L118)。


## 各算子的列裁剪实现：

本章节将对于目前实现的所有列裁剪方式进行详细介绍。默认情况下，优化器会在当前算子的列裁剪完成之后将列需求集合传递下去。

#### baseLogicalPlan
对于默认算子，优化器不进行列裁剪。

#### LogicalProjection

如果投影的结果中含有上层算子所不需要的列，那么这些列就应该删除掉。基于这个原则，优化器会去除当前算子中不在 列需求集合 中的列。（特别的，对于被赋值或sleep的表达式所涵盖的列，优化器不予删除）

同时投影的列需求和上层算子无关，优化器采用当前投影算子所需要的列作为传递下去的列需求集合。


#### LogicalSelection
select 算子的条件语句会引入一些新的列，这些列会被优化器加入下传的列需求集合中。

#### LogicalAggregation

aggregation 算子的列裁剪相对较为复杂，大致可以分为以下四个阶段：
首先，优化器对于当前算子中的聚合函数进行扫描，如果一个聚合函数的结果没有被上层算子使用，那么就删除这个聚合函数。

接着，优化器遍历所有的列，将各聚合函数所涉及到的列加入下传的列需求集合。

此时，如果所有的聚合函数都在第一阶段被删除掉，优化器会加入一个类型为 FirstRowColumn 的默认聚合函数，来保证逻辑计划的正确性。

最后，优化器遍历当前算子的 group by 条件，对 group by 条件进行裁剪，去除常量和 Null，并将必要列加入下传的列需求集合中。

#### LogicalSort, LogicalTopN, 
对于排序和 topN 算子，和 aggregation 算子裁剪的第四阶段类似，优化器会对于当前算子的 by 条件进行裁剪，去除常量和 Null，并将必要列加入下传的列需求集合中。

#### LogicalUnionAll
对于 UnionAll 算子，其裁剪发生在子算子的裁剪之后，分为两种情况：

如果当前 UnionAll 算子的列不为上层算子所用，优化器不对当前算子进行裁剪，并以当前 UnionAll 算子作为基准，以其本身包含的列作为下传的列需求集合传到下层算子。

如果当前 UnionAll 算子的列为上层算子所用，优化器则直接将列需求集合传递下去，并在最后调整 UnionAll 算子的列和子算子保持一致。

#### LogicalUnionScan
对于 UnionScan 算子，优化器直接在列需求集合中加入当前算子的 handle columns，不进行列裁剪。

#### DataSource

在优化器中，经过上层算子的层层裁剪，列需求最终被传到 Datasource 算子上，并由其做最后的裁剪工作。该算子的裁剪不需要计算下传的列需求，只需对当前算子进行裁剪即可，该裁剪工作大致分为三步：

首先，优化器会删除既没有被上层算子需要，又没有被当前算子的条件语句所需要的列。

此时，如果所有列都被删除了，则加入 handle columns 来补足。

最后，优化器扫描 handle columns ，对于没有对应 index 的 handle column 进行删除。

#### LogicalTableDual
类似 Datasource 算子，TableDual 算子也只需要对当前算子进行裁剪。不同在于第一步：优化器在裁剪时会删去当前算子中没有被上层算子用过的列。

#### LogicalJoin
相对其他算子，Join 算子的列裁剪比较特殊，因为 Join 算子的列是由 Join 的两个对象决定的。同时，由于其独特的性质， Join 算子本身的列裁剪不会对下层算子的列需求产生影响。因此，在优化器中，对于 Join 算子本身列的裁剪发生在下层算子的裁剪之后。具体步骤分为三步：

第一步：优化器从 Join 的条件语句中提取出左右算子的列需求集合，并用其对于左右算子分别进行列裁剪。

第二步：优化器将左右算子裁剪后得到的列进行合并。

第三步：优化器对于合并得到的列进行裁剪。

#### LogicalApply
LogicalApply 算子的裁剪类似于 LogicalJoin 算子的裁剪，也是先进行左右两列的裁剪。不同在于第一个阶段的执行：由于 LogicalApply 存在执行先后顺序 以及 存在两个算子间列需求的传递，优化器会先执行右侧算子的列裁剪，并将右侧列裁剪得到的结果放入左侧算子的列需求中。

#### LogicalLock

对于不是 Select Lock For Update 的 LogicalLock 算子，优化器直接按照 baseLogicalPlan 的处理方式进行处理。而对于符合条件的算子，分为两种情况进行处理：

如果当前算子对应 partitioned table，出于计算 lock key 的考量，优化器会保留当前算子的所有列，直接将这些列作为下传的列需求。

如果当前算子不对应 partitioned table，直接将 table Id 作为 handle column 加入当前的列需求集合，作为下传的列需求集合。

#### LogicalWindow

对于 Window 算子，其本身的信息的裁剪取决于下层阶段的裁剪，所以优化器会先进行其子算子的裁剪。具体流程分为两步：

首先，优化器会先利用 Window 算子所需要的列对下传来的列需求集合进行调整，只保留共同需要的列作为下传的列需求集合。

接下里，在下层算子的列裁剪完成后，优化器会反过来调整 Window 算子的表信息，让其和下层保持一致。